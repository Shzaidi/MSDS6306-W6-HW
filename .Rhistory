panel = panel.lmbands,
main = "T-Cell Response vs Stone Mass",
xlab = "Stone Mass (g)",
ylab = "Health level or T-Cell Response (mm)",
ylim = c(-0.1, 0.60),
xlim = c(2, 10),
frame.plot = FALSE,
col = ifelse(TC > 0.35, "red", "blue"),
data = data8)
xyplot(Tcell ~ Mass,
panel = panel.lmbands,
main = "T-Cell Response vs Stone Mass",
xlab = "Stone Mass (g)",
ylab = "Health level or T-Cell Response (mm)",
ylim = c(-0.1, 0.60),
xlim = c(2, 10),
frame.plot = FALSE,
col = ifelse(TC > 0.35, "red", "blue"),
data = data8)
par(mfrow = c(1,2))
qqnorm(Fit$residuals)
plot(Fit$fitted, Fit$residuals)
newdata = data.frame(Mass = 5.91)
predict(Fit, newdata, interval = "predict")
predict(Fit, newdata, interval = "confidence")
head(data8)
?distribution
?boot
install.packages("boot")
?boot
??boot
library(ggplot2)
library(stats)
library(utils)
library(boot)
x <- c(187, 169, 123, 166, 199, 127, 159, 155, 145, 142, 171)
y <- c(122, 45, 98, 38, 148, 179, 193, 54, 22, 245)
n1 <- length(x)
n2 <- length(y)
k <- 100000
set.seed(1234)
simXsample <- replicate(k, rnorm(n1, mean(x), sd(x)))
simYsample <- replicate(k, rnorm(n2, mean(y), sd(y)))
simMeanDifs <- apply(simXsample, 2, mean) - apply(simYsample, 2, mean)
quantile(simMeanDifs, c(0.025 , 0.975)
quantile(simMeanDifs, c(0.025 , 0.975)
?quantile
simMeanDifs <- apply(simXsample, 2, mean) - apply(simYsample, 2, mean)
quantile(simMeanDifs, c(0.025 , 0.975)
Hist(simMeanDifs, col="red", nclass=30)
Hist(simMeanDifs, col="red", nclass=30)
hist(simMeanDifs, col="red", nclass=30)
quantile(simMeanDifs, c(0.025,0.975))
quantile(simMeanDifs, c(0.005,0.995))
hist(simMeanDifs, col="red", nclass=10)
hist(simMeanDifs, col="red", nclass=50)
summary(x)
summary(y)
summary(simMeanDifs)
summary (x - y)
difs <- x - y
summary(simXsample)
summary(simMeanDifs)
lambda1 <- 1 / mean(x)
lambda2 <- 1/ mean(y)
Day1Waiting <- c(23.6, 42.9, 53.4, 73.4, 1.6, 2.4, 13.6, 2.1)
Day2Waiting <- c(15.6, 34.5, 67.0, 89.0, 2.4, 1.8, 16.4)
lambda1 <- 1 / mean(Day1Waiting)
lambda2 <- 1/ mean(Day2Waiting)
L1 <- length(Day1Waiting)
L2 <- length(Day2Waiting)
simXsample_exp <- replicate(k, rexp(L1, lambda1))
simYsample_exp <- replicate(k, rexp(L2, lambda2))
simExpMeanDifs <- apply(simXsample_exp, 2, mean) - apply(simYsample_exp, 2, mean)
quantile(simMeanDifs, c(0.025,0.975))    # i.e. 95% Confidence Interval
quantile(simExpMeanDifs, c(0.025,0.975))    # i.e. 95% Confidence Interval
set.seed(9876)
k <- 100000
Day1Waiting <- c(23.6, 42.9, 53.4, 73.4, 1.6, 2.4, 13.6, 2.1)
Day2Waiting <- c(15.6, 34.5, 67.0, 89.0, 2.4, 1.8, 16.4)
L1 <- length(Day1Waiting)
L2 <- length(Day2Waiting)
lambda1 <- 1 / mean(Day1Waiting)
lambda2 <- 1/ mean(Day2Waiting)
simXsample_exp <- replicate(k, rexp(L1, lambda1))
simYsample_exp <- replicate(k, rexp(L2, lambda2))
# Compute mean differences of n1 & n2 simulated observations k times:
simExpMeanDifs <- apply(simXsample_exp, 2, mean) - apply(simYsample_exp, 2, mean)
# find the two relevant quantiles of k simulated mean differences
quantile(simExpMeanDifs, c(0.025,0.975))    # i.e. 95% Confidence Interval
quantile(simExpMeanDifs, c(0.005,0.995))    # i.e. 99% Confidence Interval
hist(simExpMeanDifs, col="blue", nclass=50)
hist(simExpMeanDifs, col="blue", nclass=150)
# Non-parametric bootstrap
NPsimXsample <- replicate(k, sample(Day1Waiting, replace = TRUE))
NPsimYsample <- replicate(k, sample(Day2Waiting, replace = TRUE))
# Compute mean differences of n1 & n2 simulated observations k times:
NPsimMeanDifs <- apply(NPsimXsample, 2, mean) - apply(NPsimYsample, 2, mean)
# find the two relevant quantiles of k simulated mean differences
quantile(NPsimMeanDifs, c(0.025,0.975))    # i.e. 95% Confidence Interval
Day3Waiting <- c(155.6, 347.5, 678.0, 893.0, 233.4, 134.8, 167.4)
L3 <- length(Day3Waiting)
NPsimXsample <- replicate(k, sample(Day1Waiting, replace = TRUE))
NPsimYsample2 <- replicate(k, sample(Day3Waiting, replace = TRUE))
# Compute mean differences of n1 & n2 simulated observations k times:
NPsimMeanDifs1vs3 <- apply(NPsimXsample, 2, mean) - apply(NPsimYsample2, 2, mean)
# find the two relevant quantiles of k simulated mean differences
quantile(NPsimMeanDifs1vs3, c(0.025,0.975))
source('~/R/Working_for_bootstrap_assignment_w4.R', encoding = 'ASCII')
install.packages("boot")
library(ggplot2)
library(stats)
library(utils)
library(boot)
# Assignment DDS - Week 4
# Write bootstrap code to illustrate the Central Limit
#   Theorem in R markdown and push result to GitHub.
# • Use a normal distribution with two different sample
#   sizes and an exponential distribution with two different
#   sample sizes.
# • Correct code alone is insufficient. Please also comment
#    the code and explain the results.
# • For help, see the lotsa.medians function in Unit 2.
# • Send link to GitHub repo to live session instructor.
# Sample Data
x <- c(187, 169, 123, 166, 199, 127, 159, 155, 145, 142, 171)
y <- c(122, 45, 98, 38, 148, 179, 193, 54, 22, 245)
n1 <- length(x)
n2 <- length(y)
# Set number of Simulations
k <- 100000
# define seed number such that the following computations
# can be replicated or reproduced
set.seed(9876)
# Simulate or Bootstrap with replacement by repliocating from
# k samples of n1 & n2 normal distributions with the right means and variances
# Also called the Parametric Bootstrap:
simXsample <- replicate(k, rnorm(n1, mean(x), sd(x)))
simYsample <- replicate(k, rnorm(n2, mean(y), sd(y)))
# Compute mean differences of n1 & n2 simulated observations k times:
simMeanDifs <- apply(simXsample, 2, mean) - apply(simYsample, 2, mean)
# find the two relevant quantiles of k simulated mean differences
quantile(simMeanDifs, c(0.025,0.975))    # i.e. 95% Confidence Interval
quantile(simMeanDifs, c(0.005,0.995))    # i.e. 99% Confidence Interval
# Plot
hist(simMeanDifs, col="red", nclass=50)
summary(simMeanDifs)
####################################################################
# if we use rexp() function instead of rnorm that signifies that
# our the differences or any other function derived from x & y (eg. area)
# is non-linear, in which case the confidence interval could be computed
# with different approaches :
# 1) simulation
# 2) analytical
# 3) theoretical derivations
# these being computationally intensive , we use simulation here:
########++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
# Call Center waiting times on 2 different days. We want to know if there
# is material difference in response time over these 2 sample days with
# small sample available. Also , for one of the days, fewer observations
# are available.
# For random time observations, an exponential distribution is the best
# applicable :
Day1Waiting <- c(23.6, 42.9, 53.4, 73.4, 1.6, 2.4, 13.6, 2.1)
Day2Waiting <- c(15.6, 34.5, 67.0, 89.0, 2.4, 1.8, 16.4)
Day3Waiting <- c(155.6, 347.5, 678.0, 893.0, 233.4, 134.8, 167.4)
L1 <- length(Day1Waiting)
L2 <- length(Day2Waiting)
L3 <- length(Day3Waiting)
lambda1 <- 1 / mean(Day1Waiting)
lambda2 <- 1/ mean(Day2Waiting)
simXsample_exp <- replicate(k, rexp(L1, lambda1))
simYsample_exp <- replicate(k, rexp(L2, lambda2))
# Compute mean differences of n1 & n2 simulated observations k times:
simExpMeanDifs <- apply(simXsample_exp, 2, mean) - apply(simYsample_exp, 2, mean)
# find the two relevant quantiles of k simulated mean differences
quantile(simExpMeanDifs, c(0.025,0.975))    # i.e. 95% Confidence Interval
quantile(simExpMeanDifs, c(0.005,0.995))    # i.e. 99% Confidence Interval
# Plot
hist(simExpMeanDifs, col="blue", nclass=150)
##################################################################################
# Non-parametric bootstrap
NPsimXsample <- replicate(k, sample(Day1Waiting, replace = TRUE))
NPsimYsample <- replicate(k, sample(Day2Waiting, replace = TRUE))
# Compute mean differences of n1 & n2 simulated observations k times:
NPsimMeanDifs <- apply(NPsimXsample, 2, mean) - apply(NPsimYsample, 2, mean)
# find the two relevant quantiles of k simulated mean differences
quantile(NPsimMeanDifs, c(0.025,0.975))    # i.e. 95% Confidence Interval
# Variation on day3
NPsimXsample <- replicate(k, sample(Day1Waiting, replace = TRUE))
NPsimYsample2 <- replicate(k, sample(Day3Waiting, replace = TRUE))
# Compute mean differences of n1 & n2 simulated observations k times:
NPsimMeanDifs1vs3 <- apply(NPsimXsample, 2, mean) - apply(NPsimYsample2, 2, mean)
# find the two relevant quantiles of k simulated mean differences
quantile(NPsimMeanDifs1vs3, c(0.025,0.975))    # i.e. 95% Confidence Interval
source('~/R/Working_for_bootstrap_assignment_w4.R', encoding = 'ASCII')
source('~/R/Working_for_bootstrap_assignment_w4.R', encoding = 'ASCII')
install.packages("boot")
install.packages(c("rj", "rj.gd"), repos = "http://download.walware.de/rj-2.0")
library(ggplot2)
library(utils)
library(stats)
N <- 10000
graphics.off()
par(mfrow = c(1,2), pty = "s")
for(k in 1:20) {
m <- (rowMeans(matrix(runif(M*k), N, k)) - 0.5)*sqrt(12*k)
hist(m, breaks = "FD", xlim = c(-4,4), main = k,
prob = TRUE, ylim = c(0,0.5), col = "lemonchiffon")
pu <- par("usr")[1:2]
x <- seq(pu[1], pu[2], len = 500)
lines(x, dnorm(x), col = "red")
qqnorm(m, ylim = c(-4,4), xlim = c(-4,4), pch = ".", col = "blue")
abline(0, 1, col = "red")
Sys.sleep(1)
}
m<-numeric(10000);
for(k in (1:20))
{
for(i in(1:10000))
{m[i]<-(mean(runif(k))-0.5)*sqrt(12*k)}
hist(m,breaks=0.3*(-15:15),xlim=c(-4,4),main=sprintf("%d",k))
}
m<-numeric(100000);
for(k in (1:20))
{
for(i in(1:100000))
{m[i]<-(mean(runif(k))-0.5)*sqrt(12*k)}
hist(m,breaks=0.3*(-15:15),xlim=c(-4,4),main=sprintf("%d",k))
}
m<-numeric(10000);
p<-0.75; for(j in (1:50))
{ k<-j*j
for(i in(1:10000))
{m[i]<-(mean(rbinom(k,1,p))-p)/sqrt(p*(1-p)/k)}
hist(m,breaks=41,xlim=c(-4,4),main=sprintf("%d",k))
}
m<-numeric(10000);
for(k in (1:20))
{
for(i in(1:10000))
{m[i]<-(mean(runif(k))-0.5)*sqrt(12*k)}
hist(m,breaks=0.3*(-15:15),xlim=c(-4,4),main=sprintf("%d",k))
}
lambda <- 0.2   # exponential parameter
nsim <- 1000    # number of simulations
n <- 40         # number of points exponentially distributed
# seed for random simulation
set.seed(4)
# creating data "sim" and "sim_mean"
sim <- matrix(rexp(n * nsim, lambda), nrow=nsim, ncol=n)
sim_mean <- rowMeans(sim) # "rowMeans" is faster then "apply".
data_mean <- mean(sim_mean)
data_var <- var(sim_mean)
print(c(data_mean, data_var))
theory_mean <- 1/lambda
theory_var <- (1/lambda)^2/n
print(c(theory_mean, theory_var))
data <- data.frame(sim_mean);
plot2 <- ggplot(data, aes(x=sim_mean, colour=Distributions));
plot2 <- ggplot(data, aes(x=sim_mean, colour=Distributions));
plot2 <- plot2 + geom_histogram(aes(y=..density.., colour = "Data"),
fill= "lightcyan3", binwidth=0.2) +
# Theoretical (red) and Simulated mean (green)
geom_vline(xintercept=theory_mean, colour="red",   linetype="dashed", size=1) +
geom_vline(xintercept=data_mean,   colour="green", linetype="dashed", size=1) +
# Normal distribution with mean/variance Theoretical (red) and Simulated (green)
stat_function(fun=dnorm, args=list(mean=theory_mean, sd=sqrt(theory_var)),
aes(colour = "Theoretical"), size = 1.0) +
stat_function(fun=dnorm, args=list(mean=data_mean, sd=sqrt(data_var)),
aes(colour = "Simulated"), size = 1.0) +
# Title,labels and legend
scale_colour_manual(values = c("lightseagreen", "red", "green")) +
labs(title="Comparison between simulated and theoretical data", x="Means", y="Density")
print(plot2)
library(ggplot2)
library(stats)
rm(list=ls())
objects()
getwd() # Set your desired work directory for saving workfile and check it by repeating the command
GDPData<-read.csv("https://d396qusza40orc.cloudfront.net/getdata%2Fdata%2FGDP.csv ", header=T, sep=",", stringsAsFactors=FALSE)
GDPData2 <- GDPData[-c(1:4,195:330), -c(3,6,7:10)]
names(GDPData2)<-c("ID","Ranking","Country", "GDP")
head(GDPData2)
tail(GDPData2)
attach(GDPData2)
dim(GDPData2) # or length (GDP) This gives us the number of countries for which we have GDP data for (eg 190)
EduData<-read.csv("https://d396qusza40orc.cloudfront.net/getdata%2Fdata%2FEDSTATS_Country.csv", header=T, sep=",", stringsAsFactors=FALSE)
names(EduData)<-c("ID","Country","Income_Group", "Region", "Lending_Group", "Other")
dim(EduData) # This gives us the number of countries for which we have EduData data for (eg 234)
# Question 1: Match the data based on the country shortcode. How many of the IDs match?
#Merging and removing duplicate country names from the Data merged dataset
Data<- merge(GDPData2, EduData, by="ID")
attach(Data)
dim(Data) # This gives us the number of countries for which we haveboth GDP and EduData data for (eg 189)
#Display and storing answer to first question
answ1 <- length(GDP)
message("Number of countries for which both data type are available is: 189")
# Question 2: Sort the data frame in ascending order by GDP rank. What is the 13th country in the resulting data frame?
# Ensuring GDP is captured as numeric vector and is not in scientific format in the dataframe (for whatever reason this step might be implemented twice to have effect)
sapply(Data,class)
typeof(GDP)
Data$GDP <- gsub("\\,","",GDP)
Data2 <-transform (Data, GDP=as.numeric(as.character(GDP)))
typeof(GDP)
# Sorting data frame as requested and displaying and storing answer 2
sort.Data2 <- Data2[order(Data2$GDP), ]
attach(sort.Data2)
sort.Data2[13,3] # Gives the names of the 13th country in the merged list by GDP asc.
answ2 <- sort.Data2[13,3]
message("The 13th country by GDP (ascending) is: St. Kitts and Nevis")
# Question 3: ÿWhat are the average GDP rankings for the "High income: OECD" and "High income: nonOECD" groups?
# Ensuring also the Ranking attribute is captured as numeric vector and verifying that no further missing values are for the attributes in scope for the rest of the exercise
sapply(sort.Data2,class)
Data3 <-transform (sort.Data2, Ranking=as.numeric(as.character(Ranking)))
sapply(Data3,class)
attach(Data3)
#Displaying and storing answer(s) 3
answ3.1<- with(Data3, mean(Ranking[Income_Group=="High income: OECD"]))
message("The avg Ranking for the ?High income: OECD? countries is: 32.9")
answ3.2<- with(Data3, mean(Ranking[Income_Group=="High income: OECD"]))
message("The avg Ranking for the ?High income: nonOECD? countries is: 91.9")
# Question 4: Plot the GDP for all of the countries. Use ggplot2 to color your plot by Income Group
plot(GDP, bty="l", col="green", pch=19, main="GDP distribution and avrgs.", xlab="Countries (asc. Order)", ylab="GDP in $m")
# And close chart
colour <- c("grey", "yellow","orange","red","black")
col.list <- rep(0, length(Data3$Income_Group))
col.list[Data3$Income_Group=="Low income"] <- 1
col.list[Data3$Income_Group=="Lower middle income"] <-2
col.list[Data3$Income_Group=="Upper middle income"] <- 3
col.list[Data3$Income_Group=="High income: nonOECD"] <- 4
col.list[Data3$Income_Group=="High income: OECD"] <- 5
p <- plot (GDP, pch=19, main="GDP per Income Group", xlab="Countries (asc. Order)", ylab="GDP in $m", col=c(colour[col.list]))
legend(x="topleft", cex=0.7, c(" Low income in Grey ",
" Lower middle income in Yellow ",
" Upper middle income in Orange ",
" High income ? non OECD in Red ",
" High income ? OECD in Black "))
# And close chart
# Question 5: Cut the GDP ranking into 5 separate quantile groups. Make a table versus Income.Group. How many countries are Lower middle income but among the 38 nations with highest GDP?
# Selecting only relevant attributes
Data4 <-Data3[c(2,6)]
sort.Data4 <- Data4[order(Ranking), ]
#Computing Ranking quintile and grouping by Income_Group
z = quantile(Ranking,c(0.2,0.4,0.6,0.8),na.rm = FALSE,names = FALSE)
z # Checking calculated quantiles
# Install and load data.table package
b<-setDT(sort.Data4)[Ranking<=z[1], quantile:= "1st"][Ranking>=z[1] & Ranking<=z[2], quantile:= "2nd"][Ranking>=z[2] & Ranking<=z[3], quantile:= "3rd"][Ranking>=z[3] & Ranking<=z[4], quantile:= "4th"][Ranking>=z[4], quantile:= "5th"]
sapply(b,class)
b1 = subset(b, quantile =="1st")
b2 = subset(b1, Income_Group =="Lower middle income")
dim(b2) #  This gives the number of Lower middle income countries in the first Ranking quantile (eg 5)
# Display and storing answer to last question 5
answ5 <- dim(b2)
message("Number of Lower middle income countries in 1st Ranking quantile is: 5")
library(mosaic)
rm(list=ls())
objects()
getwd()
setwd("C:\\Users\\najee\\Documents\\R\\MSDS6306-W6-HW")
GDPData<-read.csv("https://d396qusza40orc.cloudfront.net/getdata%2Fdata%2FGDP.csv ", header=T, sep=",", stringsAsFactors=FALSE)
GDPData2 <- GDPData[-c(1:4,195:330), -c(3,6,7:10)]
names(GDPData2)<-c("ID","Ranking","Country", "GDP")
head(GDPData2)
tail(GDPData2)
attach(GDPData2)
?setDT
??setDT
install.packages("texreg")
library(texreg)
??sort.
??sort
library(ggplot2)
library(stats)
library(mosaic)
library(texreg)
rm(list=ls())
objects()
getwd()
setwd("C:\\Users\\najee\\Documents\\R\\MSDS6306-W6-HW")
GDPData <- read.csv("https://d396qusza40orc.cloudfront.net/getdata%2Fdata%2FGDP.csv ", header=T, sep=",", stringsAsFactors=FALSE)
GDPData2 <- GDPData[-c(1:4,195:330), -c(3,6,7:10)]
names(GDPData2) <- c("ID","Ranking","Country", "GDP")
head(GDPData2)
tail(GDPData2)
attach(GDPData2)
dim(GDPData2)
EduData <- read.csv("https://d396qusza40orc.cloudfront.net/getdata%2Fdata%2FEDSTATS_Country.csv", header = TRUE, sep = ",", stringsAsFactors = FALSE)
names(EduData) <- c("ID","Country","Income_Group", "Region", "Lending_Group", "Other")
dim(EduData)
Data <- merge(GDPData2, EduData, by = "ID")
attach(Data)
dim(Data)
answ1 <- length(GDP)
answ1
sapply(Data,class)
typeof(GDP)
Data$GDP <- gsub("\\,","",GDP)
Data2 <- transform(Data, GDP = as.numeric(as.character(GDP)))
typeof(GDP)
sort.Data2 <- Data2[order(Data2$GDP), ]
attach(sort.Data2)
sort.Data2[13,3] # Gives the names of the 13th country in the merged list by GDP asc.
answ2 <- sort.Data2[13,3]
sapply(sort.Data2,class)
Data3 <- transform(sort.Data2, Ranking = as.numeric(as.character(Ranking)))
sapply(Data3,class)
attach(Data3)
answ3.1 <- with(Data3, mean(Ranking[Income_Group == "High income: OECD"]))
answ3.2 <- with(Data3, mean(Ranking[Income_Group == "High income: OECD"]))
plot(GDP, bty = "l", col = "green", pch = 19,
main = "GDP distribution and avrgs.",
xlab = "Countries (asc. Order)",
ylab = "GDP in $m")
colour <- c("grey", "yellow","orange","red","black")
col.list <- rep(0, length(Data3$Income_Group))
col.list[Data3$Income_Group == "Low income"] <- 1
col.list[Data3$Income_Group == "Lower middle income"] <- 2
col.list[Data3$Income_Group == "Upper middle income"] <- 3
col.list[Data3$Income_Group == "High income: nonOECD"] <- 4
col.list[Data3$Income_Group == "High income: OECD"] <- 5
p <- plot(GDP, pch = 19, main = "GDP per Income Group",
xlab = "Countries (asc. Order)",
ylab = "GDP in $m",
col = c(colour[col.list]))
Data4 <- Data3[c(2,6)]
sort.Data4 <- Data4[order(Ranking), ]
z = quantile(Ranking,c(0.2,0.4,0.6,0.8),na.rm = FALSE,names = FALSE)
b <- setDT(sort.Data4)[Ranking <= z[1], quantile := "1st"][Ranking >= z[1] & Ranking <= z[2], quantile := "2nd"][Ranking >= z[2] & Ranking<=z[3], quantile:= "3rd"][Ranking >= z[3] & Ranking<=z[4], quantile:= "4th"][Ranking >= z[4], quantile:= "5th"]
sapply(b,class)
b1 = subset(b, quantile == "1st")
b2 = subset(b1, Income_Group == "Lower middle income")
library(mosaic)
library(stats)
library(ggplot2)
library(texreg) # Version:1.36.7, Date:2016-06-21, Author: Philip Leifeld (University of Glasgow)
Data <- merge(GDPData2, EduData, by = "ID")
attach(Data)
dim(Data)
answ1 <- length(GDP)
answ1
message("Number of countries for which both data type are available is: 189")
sapply(sort.Data2,class)
Data3 <- transform(sort.Data2, Ranking = as.numeric(as.character(Ranking)))
sapply(Data3,class)
attach(Data3)
#Displaying and storing answer(s) 3
answ3.1 <- with(Data3, mean(Ranking[Income_Group == "High income: OECD"]))
answ3.1
message("The avg Ranking for the ?High income: OECD? countries is: 32.9")
answ3.2 <- with(Data3, mean(Ranking[Income_Group == "High income: OECD"]))
answ3.2
message("The avg Ranking for the ?High income: nonOECD? countries is: 91.9")
Data4 <- Data3[c(2,6)]
sort.Data4 <- Data4[order(Ranking), ]
# Computing Ranking quintile and grouping by Income_Group
z = quantile(Ranking,c(0.2,0.4,0.6,0.8),na.rm = FALSE,names = FALSE)
# Checking calculated quantiles
b <- setDT(sort.Data4)[Ranking <= z[1], quantile := "1st"][Ranking >= z[1] & Ranking <= z[2], quantile := "2nd"][Ranking >= z[2] & Ranking<=z[3], quantile:= "3rd"][Ranking >= z[3] & Ranking<=z[4], quantile:= "4th"][Ranking >= z[4], quantile:= "5th"]
sapply(b,class)
b1 = subset(b, quantile == "1st")
b2 = subset(b1, Income_Group == "Lower middle income")
dim(b2) #  This gives the number of Lower middle income countries in the first Ranking quantile (eg 5)
# Display and storing answer to last question 5
answ5 <- dim(b2)
message("Number of Lower middle income countries in 1st Ranking quantile is: 5")
library(texreg) # Version:1.36.7, Date:2016-06-21, Author: Philip Leifeld (University of Glasgow)
Data4 <- Data3[c(2,6)]
sort.Data4 <- Data4[order(Ranking), ]
z = quantile(Ranking,c(0.2,0.4,0.6,0.8),na.rm = FALSE,names = FALSE)
z
b <- setDT(sort.Data4)[Ranking <= z[1], quantile := "1st"][Ranking >= z[1] & Ranking <= z[2], quantile := "2nd"][Ranking >= z[2] & Ranking<=z[3], quantile:= "3rd"][Ranking >= z[3] & Ranking<=z[4], quantile:= "4th"][Ranking >= z[4], quantile:= "5th"]
??texreg::setDT
?setDT
??setDT
library(data.table)
b <- setDT(sort.Data4)[Ranking <= z[1], quantile := "1st"][Ranking >= z[1] & Ranking <= z[2], quantile := "2nd"][Ranking >= z[2] & Ranking<=z[3], quantile:= "3rd"][Ranking >= z[3] & Ranking<=z[4], quantile:= "4th"][Ranking >= z[4], quantile:= "5th"]
sapply(b,class)
b1 = subset(b, quantile == "1st")
b2 = subset(b1, Income_Group == "Lower middle income")
dim(b2) #  This gives the number of Lower middle income countries in the first Ranking quantile (eg 5)
answ5 <- dim(b2)
library(data.table)
Data4 <- Data3[c(2,6)]
sort.Data4 <- Data4[order(Ranking), ]
# Computing Ranking quintile and grouping by Income_Group
z = quantile(Ranking,c(0.2,0.4,0.6,0.8),na.rm = FALSE,names = FALSE)
z
# Checking calculated quantiles
b <- setDT(sort.Data4)[Ranking <= z[1], quantile := "1st"][Ranking >= z[1] & Ranking <= z[2], quantile := "2nd"][Ranking >= z[2] & Ranking<=z[3], quantile:= "3rd"][Ranking >= z[3] & Ranking<=z[4], quantile:= "4th"][Ranking >= z[4], quantile:= "5th"]
sapply(b,class)
b1 = subset(b, quantile == "1st")
b2 = subset(b1, Income_Group == "Lower middle income")
dim(b2) #  This gives the number of Lower middle income countries in the first Ranking quantile (eg 5)
# Display and storing answer to last question 5
answ5 <- dim(b2)
message("Number of Lower middle income countries in 1st Ranking quantile is: 5")
library(ggplot2)
library(stats)
library(mosaic)
library(data.table)
rm(list = ls())
objects()
getwd()
setwd("C:\\Users\\najee\\Documents\\R\\MSDS6306-W6-HW")
GDPData <- read.csv("https://d396qusza40orc.cloudfront.net/getdata%2Fdata%2FGDP.csv ",
header=T, sep=",",
stringsAsFactors = FALSE)
GDPData2 <- GDPData[-c(1:4,195:330), -c(3,6,7:10)]
names(GDPData2) <- c("ID","Ranking","Country", "GDP")
dim(GDPData2)
setwd("~/R/MSDS6306-W6-HW")
